import java.util.Scanner;

public class Test1 {

//    题目描述
//    数据结构基础之一——队列
//    队列有五种基本操作，插入队尾、取出队首、删除队首、队列大小、清空队列。
//
//    现在让你模拟一个队列的操作，具体格式参考输入。
//    输入描述:
//    第一行输入一个整数，表示接下来有组测试数据。
//    对于每组测试数据：
//    第一行输入一个整数，表示有次操作。
//    接下来行，每行输入一种队列操作方式，具体格式如下：
//
//    初始状态下队列为空。
//
//    插入队尾：PUSH X
//    取出队首：TOP//仅仅是看一下队首元素，不要把队首元素删除
//    删除队首：POP
//    队列大小：SIZE
//    清空队列：CLEAR
//
//
//
//    保证操作为以上5种的任意一种。
//    输出描述:
//    对于每组测试数据：
//    如果操作为“取出队首”，输出队首元素，如果无法取出，输出“-1”
//    如果操作为“删除队首”，如果无法删除，输出“-1”
//    如果操作为“队列大小”，输出队列大小
//            其他操作无需输出
//    示例1输入输出示例仅供调试，后台判题数据一般不包含示例
//            输入
//    复制
//        2
//        7
//    PUSH 1
//    PUSH 2
//    TOP
//            POP
//    TOP
//            POP
//    POP
//        5
//    PUSH 1
//    PUSH 2
//    SIZE
//            POP
//    SIZE
//            输出
//        1
//        2
//        -1
//        2
//        1

//    题目描述
//    小Q在平面上给定了个点，这些点个属于集合，个属于集合，现在让你在集合和集合中各选择一个点，求所有可能中两个点的最短距离为多少？这里的距离指的是欧氏距离，对于点(x_1, y_1), (x_2, y_2)他们的欧式距离为:。
//    输入描述:
//    第一行输入一个整数，代表集合和集合内的点的数量为。
//    接下来行，每一行个数和，代表集合内的点的坐标
//    接下来行，每一行个数和，代表集合内的点的坐标
//
//
//    输出描述:
//    对于每组数据，输出一个答案代表最短距离，结果保留位小数。
//    示例1输入输出示例仅供调试，后台判题数据一般不包含示例
//            输入
//    复制
//2
//        4
//        0 0
//        0 1
//        1 0
//        1 1
//        2 2
//        2 3
//        3 2
//        3 3
//        4
//        0 0
//        0 0
//        0 0
//        0 0
//        0 0
//        0 0
//        0 0
//        0 0
//    输出
//            复制
//1.414
//        0.000


//    题目描述
//    有张卡牌，第张牌正面为 a_i 反面为 b_i，张牌排成一行，一开始全部正面朝上，现在可以执行若干次操作，每次操作可以选择相邻的两张牌，先交换它们的顺序，再翻转它们，求最少的操作次数，能使得牌上的数字从左到右非降。
//    输入描述:
//    第一行输入一个正整数表示 ，第二行个整数表示序列，第三行个整数表示序列。
//    输出描述:
//    输出一个数字表示答案，无解输出
//    示例1输入输出示例仅供调试，后台判题数据一般不包含示例
//            输入
//    复制
//3
//        1 3 2
//        3 2 1
//    输出
//            复制
//1


//    题目描述
//    用两个栈实现队列，支持队列的基本操作。
//
//    输入描述:
//    第一行输入一个整数N，表示对队列进行的操作总数。
//
//    下面N行每行输入一个字符串S，表示操作的种类。
//
//    如果S为"add"，则后面还有一个整数X表示向队列尾部加入整数X。
//
//    如果S为"poll"，则表示弹出队列头部操作。
//
//    如果S为"peek"，则表示询问当前队列中头部元素是多少。
//
//
//
//    数据保证没有不合法的操作。
//    输出描述:
//    对于每一个为"peek"的操作，输出一行表示当前队列中头部元素是多少。
//    示例1输入输出示例仅供调试，后台判题数据一般不包含示例
//            输入
//    复制
//6
//    add 1
//    add 2
//    add 3
//    peek
//            poll
//    peek
//            输出
//    复制
//1
//        2

//    给你一棵无限深度的满二叉树，节点的编号按层次依次编号，即第一层节点编号为,第二层节点编号为，第三层节点编号为以此类推。
//    接下来有次询问，每一次询问让你找一个编号为的结点在深度为的祖先节点的编号是多少？
//    输入描述:
//    输入第一行一个整数，代表有次询问
//    接下来行，每一行输入两个数和。
//
//
//
//    输出描述:
//    对于每一组测试数据，如果深度为的祖先存在，输出结点编号，不存在输出
//    示例1输入输出示例仅供调试，后台判题数据一般不包含示例
//            输入
//    复制
//4
//        10 1
//        10 2
//        10 3
//        10 4
//    输出
//            复制
//1
//        2
//        5
//        -1

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        int x;

        if (t > 100 || t < 0){
            System.out.println("input false");
            return;
        }

        int []a = new int [1000];
        // size = last +1;
        int last = 0;

        for(int i = 0; i < t; i++){
            for (int s = 0 ; s < last; s++){
                a[s] = 0;
            }
            last = 0 ;
            int q = sc.nextInt();
            if (q > 1000 || q < 0){
                System.out.println("input false");
                return;
            }
            System.out.println("input iter " + q );

            for(int j = 0; j < q; j++){
                String c = sc.next();
                c.toUpperCase();

                if (c.equals( "PUSH") ){
                    x = sc.nextInt();
                    if (x > 1000 || x < 0) {
                        System.out.println("input false");
                        return;
                    }

                    a[last] = x ;
                    last++;

                }else if (c.equals("TOP")){
                    System.out.println(a[0]);

                }else if (c.equals("POP")){
//                    System.out.println(a[0]);

                    if(a[last] == 0 && last == 0){
                        System.out.println(-1);
                        continue;
                    }

                    for (int p = 0 ; p < last; p++){
                        a[p]=a[p+1];

                    }
                    a[last] = 0;
                    last --;

                } else if (c.equals( "SIZE")){
                    System.out.println(last);

                }else if (c.equals( "CLEAR")){
                    for (int s = 0 ; s < last; s++){
                        a[s] = 0;
                    }
                }else{
                    break;
                }
            }

        }

        sc.close();
        return ;

    }


}
